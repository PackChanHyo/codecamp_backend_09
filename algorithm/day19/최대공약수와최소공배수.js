function solution(n, m) {
  let max = 0; // 공약수 중에서 가장 큰 수만 저장
  //최대 공약수
  for (let i = 1; i <= m; i++) {
    if (n % i === 0 && m % i === 0) {
      max = i;
    }
  }
  let min = 0; // 공배수 중에서 가장 작은 수만 저장
  //최소 공배수
  for (let i = m; i <= m * n; i += m) {
    if (i % n === 0) {
      min = i;
      break;
    }
  }
  return [max, min];
}

// function solution(n, m) {
// 유클리드 활용법
// - 최대공약수를 구하기 위한 알고리즘
//
// a를 b로 나누었을 때( a > b, 큰 수를 더 작은 수로 나누었을때)
// 나머지값이 0이 되며느 더 작은 수(b가 최대공약수가 된다.
// 나머지 값이 0이 되지 않으면, 작은수(B)가 큰수(a)가 되고
// 나머지 값이 작은 수
// 위 과정을 계속 반복합니다
//
// let a = m
// let b = n
// let r = 0;
//
// while(a % b > 0){
// r = a % b // 큰 수에 더 작은 수를 다시 할당
// a= b // 큰 수에는 나눴을 때의 더 작은 수를 할당
// b= r // 작은 수에는 나머지 값을 할당
// }
//
// 최소공배수는 두 수를 곱한 수에 최대공약수를 나눠준 몫의 값
// return [ b, (n*m)/ b]
// }
